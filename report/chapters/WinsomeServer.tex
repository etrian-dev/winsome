\section{Server Winsome}
\subsection{Argomenti da riga di comando}
Il server può ricevere uno o più dei seguenti parametri da riga di comando, che ne influenzano il comportamento all'avvio. Si noti che i valori passati tramite queste opzioni hanno la precedenza su quelli eventualmente letti dai file di configurazione.\\
Se in entrambi i casi non è stato specificato alcun valore per un parametro, verrà usato il valore di default statico presente nel file \verb|ServerConfig.java|.

\begin{itemize}
	\item \verb|-c --configure <FILE>|: path del file di configurazione che il server deve caricare
	\item \verb|-h --help|: messaggio di uso del server
	\item \verb|-p --socket-port <PORT>|: porta sulla quale, se possibile, viene creata la ServerSocket sulla quale il server si mette in ascolto per accettare le
	connessioni dai client
	\item \verb|-r --registry <PORT>|: porta sulla quale, se possibile, viene creato il registry RMI utilizzato sia per la registrazione, che per l'iscrizione/disiscrizione dal servizio di aggiornamento dei followers
\end{itemize}

\subsection{Configurazione}
Il server è configurato attraverso un file JSON che viene cercato, nell'ordine, ai seguenti path:
\begin{enumerate}
	\item il path passato attraverso l'opzione \verb|-c <path>|
	\item \verb|config.json| nella directory corrente
	\item \verb|./data/WinsomeServer/config.json| il file di configurazione di default
\end{enumerate}
Se tutte le opzioni precedenti non contengono un file di configurazione valido allora il server termina immediatamente.\\
I parametri configurabili sono i seguenti:
\begin{description}
	\item[dataDir]: Il path alla directory contenente i dati del server, ovvero la directory
	che contiene il file \verb|users.json|, la directory \verb|blogs|, etc ...
	\item[registryPort]: La porta del registry RMI nel quale inserire lo stub per la registrazione. Il valore deve essere un intero nel range [0, 65535]
	\item[serverSocketAddress]: Nome host o indirizzo IP del ServerSocket creato dal server per accettare le connessioni dai client (IP pubblico del server nel caso generale, ma in questo caso localhost)
	\item[serverSocketPort]: Porta alla quale deve essere legato il socket sopracitato, nel range [0, 65535]
	\item[minPoolSize]: Intero ($>0$) che rappresenta il numero di core thread nella threadpool per la gestione delle richieste del server
	\item[maxPoolSize]: Intero ($x : INT\_MIN \le minPoolSize \le x < INT\_MAX$) che rappresenta il numero massimo di thread che possono essere gestiti contemporaneamente dalla threadpool
	\item[workQueueSize]: Dimensione della coda di task che la threadpool può accumulare in attesa che un thread del pool sia libero, in accordo con la politica di gestione delineata dalla documentazione di ThreadPoolExecutor
	\item[retryTimeout]: long ($>0$) che rappresenta il numero di millisecondi che l'handler per la gestione delle richieste rifiutate dal threadpool attende prima di provare a sottomettere nuovamente la richesta
	\item[callbackInterval]: long ($>0$) che rappresenta l'intervallo tra due consecutivi aggiornamenti alla lista dei follower del client registrato al servizio. L'unità di misura che quantifica il valore è specificata dal parametro indicato di seguito
	\item[callbackIntervalUnit]: Unità di misura di callbackInterval. Essendo rappresentato con una\\
	\hyperref{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/TimeUnit.html#enum.constant.summary}{category}{name}{TimeUnit} i valori possibili sono quelli dell'enumerazione indicati nel link. Di default l'unità di tempo sono i secondi. Nel file JSON una TimeUnit è serializzata come stringa, quindi per indicare di misurare callbackInterval in secondi è sufficiente scrivere
	"callbackIntervalUnit": "SECONDS" nel file JSON.
\end{description}
Non è necessario specificare tutti i parametri nel file, poiché quelli assenti assumeranno i valori di default definiti nella classe \verb|ServerConfig.java|. Il file JSON viene deserializzato utilizzando Jackson con ObjectMappper in un'istanza della classe menzionata, ed un riferimento ad essa viene passato alla creazione del server, nel main.\\
Nella classe è in realtà presente anche il campo (non serializzato) configFile, che serve soltanto per determinare, nella funzione \verb|getServerConfiguration()| in \verb|main()|, se era stato settato con l'opzione -c il path per un file di configurazione, che ha la precedenza rispetto a quello di default.

\subsection{Esecuzione}
Il codice del server Winsome è contenuto all'interno del package WinsomeServer; la classe ServerMain in tale package contiene il metodo main, quindi è quella da eseguire per far partire il server.

\subsubsection{Thread e gestione della concorrenza}
Il server Winsome è multithreaded: vi è il thread main, il cui compito è l'inizializzazione del server e del registry; dal thread principale è fatta partire un istanza di \verb|WinsomeServer|, sottoclasse di \verb|Thread|, che si occupa di gestire lo smistamento delle richieste attraverso un selector. Una volta lanciato con successo il WinsomeServer il thread main termina.\\
Nel thread del WinsomeServer vi è un selector che permette di leggere le richieste provenienti dai client e sottometterle ad una threadpool le cui dimensioni minime e massime sono fissate dal file di configurazione.\\
Nel costruttore di WinsomeServer, inoltre, viene attivato un thread per leggere gli utenti di winsome dal file \verb|users.json| e caricarli in memoria. Una volta letti gli utenti viene attivato un \verb|BlogLoaderThread| per ogni utente letto dal file, il cui compito è deserializzare dal file \verb|<datadir>/blogs/<user>.json| tutti i post presenti in tale blog e caricarli nelle strutture dati del server (mappa post globale e lista dei post di ogni blog). Tali thread terminano una volta caricato il blog (il thread che esegue il costruttore di WinsomeServer si blocca finché la join su ciascuno di essi non ritorna).\\
Alla terminazione del server, poiché lo stato deve persistere, ogni utente ed ogni post dei loro blog devono essere scritti su file. Per fare questo è stato utilizzato
il meccanismo degli shutdown hook, settati come prima istruzione del metodo \verb|run()| del WinsomeServer.\\
Vi è un hook (thread su cui non è stato invocato \verb|start()|) per la sincronizzazione del file degli utenti: \textbf{SyncUsersThread.java}. L'altro hook è \textbf{SyncBlogsThread.java}, il cui unico compito è quello di creare e far partire un \textbf{SyncPostsThread.java} per ogni utente Winsome, che sincronizza i post di un solo blog. Tali thread operano su dati totalmente indipendenti, per cui non è richiesta alcuna sincronizzazione delle loro operazioni, il che consente di avere il massimo grado di parallelizzazione del processo consentito dalla macchina. L'unica accortezza è che il thread che li ha creati non termini fino a che tutti questi thread non sono terminati, altrimenti la JVM potrebbe terminare lasciando uno o più blog in uno stato inconsistente, che provovcherebbe degli errori al riavvio del server.